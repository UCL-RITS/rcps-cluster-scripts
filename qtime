#!/bin/bash
#
#==========================================================================
# Name: Average Queuing Time
# Author: Chris Bingham
# Date: 12.02.2009
# Language: Bash
# External References: qacct, grep, cut, bc
# Taken from: http://wiki.gridengine.info/wiki/index.php/Utilities
#
# This script will calculate the average time jobs have had to spent
# queuing before being run over the specified time period
#==========================================================================

# Store the first argument
DAYS="$1"

function display_help() {
  # Display a help message
  echo "---Average Queuing Time---"
  echo "This script will calculate the average time jobs have had to spent"
  echo "queuing before being run over the specified time period"
  echo ""
  echo "--Usage--"
  echo -e "  qtime.sh [DAYS|OPTION]"
  echo -e "  Where 'DAYS' is a number of days to calculate the average for or 'OPTION' is one of the following;"
  echo -e "  \tweek\t\t\tCalculate the average for the week so far"
  echo -e "  \tmonth\t\t\tCalculate the average for the month to date"
  echo -e "  \tyear\t\t\tCalculate the average for the year to date"
  echo -e "  \thelp\t\t\tDisplay this message"
}

function gen_human_readable_time() {
  # Convert a time in seconds into a more human-friendly scale (hours, days etc instead of seconds)
  
  # If the time span is less than 1 hour, convert to minutes
  if [ "$TIME_INT" -lt "60" ] ; then
    TIME="$TIME seconds"
  elif [ "$TIME_INT" -lt "3600" ] ; then
    TIME=`echo "scale=2; $TIME/60" | bc`
    TIME="$TIME minutes"
  # If the time span is less than 1 day, convert to hours
  elif [ "$TIME_INT" -lt "86400" ] ; then
    TIME=`echo "scale=2; $TIME/3600" | bc`
    TIME="$TIME hours"
  # If the time span is less than 1 week, convert to days
  elif [ "$TIME_INT" -lt "604800" ] ; then
    TIME=`echo "scale=2; $TIME/86400" | bc`
    TIME="$TIME days"
  # If the time span is less than 1 year, convert to weeks
  elif [ "$TIME_INT" -lt "31449600" ] ; then
    TIME=`echo "scale=2; $TIME/604800" | bc`
    TIME="$TIME weeks"
  # If the time span is 1 year or more, convert to years
  else
    TIME=`echo "scale=2; $TIME/31449600" | bc`
    TIME="$TIME years"
  fi
}

function calc_avg() {
  # Set the field seperator for array creation to a new line
  OLDIFS=$IFS
  IFS=$'\n'
  
  # Get information for SGE using the 'qacct' command, storing submit and start times in arrays
  USER_JOB_COUNT=`qacct -j -d $DAYS | grep "jobname" -c`
  USER_SUBMIT_TIMES=($(qacct -j -d $DAYS | grep "qsub_time" | cut -d " " -f 5-9))
  USER_START_TIMES=($(qacct -j -d $DAYS | grep "start_time" | cut -d " " -f 4-9))
  
  # Get the length of one of the arrays
  USER_SUBMIT_TIMES_COUNT=${#USER_SUBMIT_TIMES[@]}
  
  # Reset the field seperator to it's previous value
  IFS=$OLDIFS

  # Create variables to store min and max wait times
  MIN_WAIT_TIME=""
  MAX_WAIT_TIME=""
  
  # Determine if any jobs have been completed ov the specified time period
  if [ "$USER_SUBMIT_TIMES_COUNT" -gt "0" ] ; then
    # If yes, then calculate the average wait time
    
    # For each element in the arrays, do the following;
    for (( i=0; i<${USER_SUBMIT_TIMES_COUNT}; i++ )) ; do
      # Convert the submit and start time to seconds since the epoch
      SUBMIT_SECONDS=`date -d "${USER_SUBMIT_TIMES[$i]}" +%s`
      START_SECONDS=`date -d "${USER_START_TIMES[$i]}" +%s`
      
      # Calculate how long the job was queuing, and add this to the total queuing time
      WAIT_TIME=$(($START_SECONDS-$SUBMIT_SECONDS))
      TOTAL_WAIT_TIME=$((TOTAL_WAIT_TIME+$WAIT_TIME))
      
      if [ -z "$MIN_WAIT_TIME" ] ; then
        MIN_WAIT_TIME=$WAIT_TIME
        MAX_WAIT_TIME=$WAIT_TIME
      else
        if [ "$MIN_WAIT_TIME" -gt "$WAIT_TIME" ] ; then
          MIN_WAIT_TIME=$WAIT_TIME
        fi
        if [ "$MAX_WAIT_TIME" -lt "$WAIT_TIME" ] ; then
          MAX_WAIT_TIME=$WAIT_TIME
        fi
      fi
      
      # Reset all variables for the next iteration of the loop
      WAIT_TIME=""
      SUBMIT_SECONDS=""
      START_SECONDS=""
    done
    
    # Calculate the average queuing time as both an integer and floating point number
    AVG_WAIT_TIME=`echo "scale=2; $TOTAL_WAIT_TIME/$USER_SUBMIT_TIMES_COUNT" | bc`
    AVG_WAIT_TIME_INT=$(($TOTAL_WAIT_TIME/$USER_SUBMIT_TIMES_COUNT))
    
    TIME_INT=$AVG_WAIT_TIME_INT
    TIME=$AVG_WAIT_TIME
    
    gen_human_readable_time
    
    AVG_WAIT_TIME=$TIME
    
    TIME_INT=$MIN_WAIT_TIME
    TIME=$MIN_WAIT_TIME
    
    gen_human_readable_time
    
    MIN_WAIT_TIME=$TIME
    
    TIME_INT=$MAX_WAIT_TIME
    TIME=$MAX_WAIT_TIME
    
    gen_human_readable_time
    
    MAX_WAIT_TIME=$TIME
    
    # Display the average queuing time
    echo ""
    echo "During the last $DAYS days, jobs had to queue (wait to be run) for;"
    echo -e "\tOn average:\t$AVG_WAIT_TIME"
    echo -e "\tAt least:\t$MIN_WAIT_TIME"
    echo -e "\tAt most:\t$MAX_WAIT_TIME"
    echo ""
  else
    # If no, then display the wait time as 0 seconds
    echo ""
                echo "During the last $DAYS days, jobs had to queue (wait to be run) for;"
                echo -e "\tOn average:\t0 seconds"
                echo -e "\tAt least:\t0 seconds"
                echo -e "\tAt most:\t0 seconds"
                echo ""

  fi
}

# Check first argument
case "$DAYS" in
  "week")
    # If 'week' is specified, determine how many days into the week we are, starting from, Monday
    DAYS=`date +%u`
    calc_avg
    ;;
  "month")
    # If 'month' is specified, determine how many days into the month we are
    DAYS=`date +%d`
    calc_avg
    ;;
  "year")
    # If 'year' is specified, determine how many days into the year we are
    DAYS=`date +%j`
    calc_avg
    ;;
  (*[0-9])
    # If the input conatains numbers, trim out all non-numeric characters and continue
    DAYS=`echo $DAYS | tr -d [:alpha:][:punct:]`
    calc_avg
    ;;
  "help")
    # If 'help' is specified, display the help message and exit
    display_help
    exit
    ;;
  *)
    # If the input is anything else, display the help message and exit
    display_help
    exit
    ;;
esac

